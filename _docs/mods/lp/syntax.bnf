<stmt> ::= <for>
         | <if>
         | <fdef>
         | <bind>
         | <logic>
         | <PASS>

<for> ::= <FOR> <forcond> <fbody>

<forcond> ::= <SYM> <IN> <range>
            | {<forstmt>}

<forlogic> ::= <logic> sepby <SEMI>

<type> ::= <TYPE> <SYM> <EQ> <fbody>

<if> ::= <IF> <logic> <fbody> [<else>]

<else> ::= <ELSE> (<if>|<fbody>)

<logic> ::= <eqcmp> (<AND>|<OR>) <logic>
          | <eqcmp>

<eqcmp> ::= <difcmp> (<EEQ>|<NEQ>) <eqcmp>
          | <difcmp>

<difcmp> ::= <expr> (<LSS>|<GTR>|<LEQ>|<GEQ>) <difcmp>
           | <expr>

<fdef> ::= <FN> <dot> {<SYM>} <EQ> <fbody>

<fbody> ::= <INDENT> {<stmt>} <DEDENT>
          | <logic>

# name: Type = something
<bind> ::= <typedsym> <bindsym> <logic>
         | <SYM> <bindsym> <logic>

<bindsym> ::= <EQ> | <AEQ> | <SEQ> | <MEQ> | <DEQ> | <MOQ>

# "name: Type" or "name"
<typedsym> ::= <dot> <COLN> <typeanno>

# "i64" or "Module.Type[5]" or "[pointer]"
<typeanno> ::= <LBRC> <dot> <RBRC>
             | <dot> <LBRC> <logic> <RBRC>
             | <dot>

# maths
<expr> ::= <term> (<ADD>|<SUB>) <expr>
         | <term>
<term> ::= <fact> (<MUL>|<DIV>|<MOD>) <term>
         | <fact>
<fact> ::= <LPAR> <logic> <RPAR>
         | <cast>

# something as OtherType
<cast> ::= <not> <AS> <typeanno>
         | <not>

# "!something" or "not something"
<not> ::= <NOT> <lit>
        | <lit>

# constant literals
<lit> ::= <call>
        | <arg>

# X to Y
<range> ::= <num> <TO> <num>

# (-)value
<num> ::= <SUB> <num>
        | <INT>
        | <FLT>

# [expr]
<ptr> ::= <LBRC> <logic> <RBRC>

# { logic1, logic2, ... }
<arr> ::= <LCRL> {<logic> sepby <COMA>} <RCLR>

# func_name arg1 arg2 ...
<call> ::= <dot> [{<arg>}]
<arg> ::= <LPAR> <logic> <RPAR>
        | <range>
        | <num>
        | <STR>
        | <CHR>
        | <ptr>
        | <arr>
	| <SYM>

# "type.field" or "type"
<dot> ::= <SYM> <DOT> <dot>
        | <SYM>
